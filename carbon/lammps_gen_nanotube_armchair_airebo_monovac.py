#!/usr/bin/env python

# This function simply generates a nanotube with an armchair end centred in a periodic box.
# The nanotube has randomly distributed mono-vacancies
# The mono-vacancies are isolated and reconstructed automatically.

# a_const defaults to the optimised value at zero K for the AIREBO force-field.
# The output is a lammps data file in atomic format (this is the required format for the AIREBO code).

# Keyword arguments:
# verbose = True   , prints some comments to the screen.
# forced  = True   , will overwrite the existing file (if it exists).
# forced  = False  , if file exists, will ask the user if the existing file should be overwritten.
# a_const = 2.4636  , the 'a' lattice constant
# filename = lammps.lattice.dat  , the output filename
# cells = [x,y]  , No. unit cells to generate for each direction.

# Kenny Jolley, August 2021

import sys
import os
import math
import numpy as np
from random import seed
from random import randint
import datetime

# todo: work in progress.
# nanotube generator function
def lammps_gen_nanotube_armchair_airebo_monovac(**kwargs):

    # Default keyword args
    verbose = kwargs.get('verbose', False)
    forced = kwargs.get('forced', False)
    # Default constants for the AIREBO force-field.
    a_const = kwargs.get('a_const', 2.42)
    filename = kwargs.get('filename', 'lammps.lattice.dat')
    cells = kwargs.get('cells', [1, 1])
    num_vacancies = int(kwargs.get('num_vacancies', 0))

    # box size and atom total
    nanotube_radius = 0.5 * math.sqrt(3) * a_const * cells[0] / math.pi
    box_y = int(2.0 * nanotube_radius) + 30.0
    box_z = int(2.0 * nanotube_radius) + 30.0
    box_x = a_const * cells[1]

    tot_atoms = int(4 * cells[0] * cells[1])

    init_box_x = math.sqrt(3) * a_const * cells[0]
    init_box_y = a_const * cells[1]

    # carbon bond length
    cc_len = a_const / math.sqrt(3.0)
    cc_len_buf = cc_len * 1.1  # 10 % buffer on the bond length
    cc_len_buf2 = cc_len_buf * cc_len_buf

    # Welcome
    if verbose:
        print("  +------------------------------------------------+")
        print("  |             Lattice generator script           |")
        print("  |                Armchair Nanotube               |")
        print("  |                AIREBO force-field              |")
        print("  |                   Kenny Jolley                 |")
        print("  |                     Feb 2021                   |")
        print("  +------------------------------------------------+")
        print("   ")

        print(">  Echoing back the user supplied data")
        print("     Lattice constant a [Ang]: " + str(a_const))
        print(">    Nanotube length [Ang]: " + str(box_x))
        print(">    Nanotube radius [Ang]: " + str(nanotube_radius))
        print(">    Nanotube circumference [Ang]: " + str(math.sqrt(3) * a_const * cells[0]))
        print(">  Nanotube lattice with unit cell repeats:")
        print("     cells_x: " + str(cells[0]))
        print("     cells_y: " + str(cells[1]))
        print(">  Nanotube lattice cell dimensions [Ang]:")
        print("     box_x: " + str(box_x))
        print("     box_y: " + str(box_y))
        print("     box_z: " + str(box_z))
        print(">  Total number of mono-vacancies: " + str(num_vacancies))
        print(">  Total number of atoms: " + str(tot_atoms - num_vacancies))

    # Set generate file flag to true
    gen_file = True

    # Check if the file already exists
    if not forced:
        if os.path.isfile(filename):
            print("> Existing file " + str(filename) + " detected.")
            print("> lammps_gen_nanotube_armchair_airebo function wants to overwrite this file")

            # Ask user if file should be overwritten
            user_choice = input('Do you wish to overwrite the existing file? (y/n): ').lower()

            if (user_choice == 'yes') or (user_choice == 'y') or (user_choice == 'yea'):
                print(" > Overwriting existing file ... ")
                gen_file = True
            else:
                print("File not overwritten, exiting function")
                gen_file = False

    # create lattice file
    if gen_file:
        file = open(filename, 'w+')
        if verbose:
            print("Opened file: " + str(file.name))

        # Write header info
        file.write("Lammps data file generated by lammps_gen_nanotube_armchair_airebo\n")
        file.write("# Nanotube " + str(cells[0]) + "x" + str(cells[1]) +
                   " Unit cells, with a_param = " + str(a_const) + "\n")
        file.write(str(tot_atoms - num_vacancies) + " atoms\n\n")
        file.write("1 atom types # C\n\n")
        file.write("0.0 " + str(box_x) + " xlo xhi\n")
        file.write("0.0 " + str(box_y) + " ylo yhi\n")
        file.write("0.0 " + str(box_z) + " zlo zhi\n\n")
        file.write("Masses\n\n")
        file.write("1 12.011\n\n")
        file.write("Atoms # atomic\n\n")

        # generate np arrays of atoms
        # atoms_array[id,coord]     # coordinates of perfect lattice
        # atoms_NN[list]         # list of the three nearest neighbours
        # atoms_NNN[list]        # list of the next nearest neighbours (not including the NN)
        # atom_deleted_flag[del] # flag set if atom is deleted

        # setup arrays
        atoms_array = np.zeros((tot_atoms, 3))
        atoms_NN = np.zeros((tot_atoms, 3), dtype=int)
        atoms_NNN = np.zeros((tot_atoms, 6), dtype=int)
        atom_deleted_flag = np.zeros(tot_atoms)

        # compute coordinates of underlying graphene lattice
        atom_id = 0
        for i in range(0, cells[0]):
            x_shift = i * math.sqrt(3) * a_const
            for j in range(0, cells[1]):
                y_shift = j * a_const

                # pos 1
                atoms_array[atom_id][0] = x_shift
                atoms_array[atom_id][1] = y_shift
                atoms_array[atom_id][2] = 0.0
                atom_id += 1

                # pos 2
                atoms_array[atom_id][0] = x_shift + a_const * 2.0 / math.sqrt(3)
                atoms_array[atom_id][1] = y_shift
                atoms_array[atom_id][2] = 0.0
                atom_id += 1

                # pos 3
                atoms_array[atom_id][0] = x_shift + a_const * math.sqrt(3) / 6.0
                atoms_array[atom_id][1] = y_shift + a_const / 2.0
                atoms_array[atom_id][2] = 0.0
                atom_id += 1

                # pos 4
                atoms_array[atom_id][0] = x_shift + a_const * math.sqrt(3) / 2.0
                atoms_array[atom_id][1] = y_shift + a_const / 2.0
                atoms_array[atom_id][2] = 0.0
                atom_id += 1

        # for each atom, need to find the three nearest neighbours and save their ids to the atoms_NN array
        # slow brute force method handles periodic boundaries
        if verbose:
            print("> Building nearest neighbour list (could be slow)")
        for atom_id in range(tot_atoms):
            num_nebs = 0
            for atom_id2 in range(tot_atoms):
                if atom_id2 != atom_id:
                    # check dx
                    dx = abs(atoms_array[atom_id][0] - atoms_array[atom_id2][0])
                    dx = min(dx, abs(dx - init_box_x))
                    if dx < cc_len_buf:
                        dy = abs(atoms_array[atom_id][1] - atoms_array[atom_id2][1])
                        dy = min(dy, abs(dy - init_box_y))
                        if dy < cc_len_buf:
                            # bond length squared
                            dr2 = dx * dx + dy * dy
                            # check within 2 angstroms
                            if dr2 < cc_len_buf2:
                                # save id to NN list
                                atoms_NN[atom_id][num_nebs] = atom_id2
                                num_nebs += 1
                                # We know there are only 3 NN's
                                if num_nebs >= 3:
                                    break

        '''print(atoms_NN[0])
        print(atoms_NN[1])
        print(atoms_NN[2])
        print(atoms_NN[3])
        print(atoms_NN[4])
        print(atoms_NN[1000])'''

        if verbose:
            print("> Building next nearest neighbour list (could be slow)")
        # for each atom, need to find the six next nearest neighbours and save their ids to the atoms_NNN array
        for atom_id in range(tot_atoms):
            k = 0
            for j in range(3):
                nn_id = atoms_NN[atom_id][j]
                for nnn in range(3):
                    if atoms_NN[nn_id][nnn] != atom_id:
                        atoms_NNN[atom_id][k] = atoms_NN[nn_id][nnn]
                        k += 1

        # loop over layers and delete the required number of atoms, then reconstruct the defect to 5-9 rings
        if verbose:
            print("> Creating and reconstructing mono-vacancies")
        seed(datetime.datetime.now())

        valid_list = [v for v in range(tot_atoms)]

        for vac in range(num_vacancies):
            # get a random element
            r = randint(0, len(valid_list) - 1)
            # delete atom and flag it and the NN's
            deleted_atom = valid_list[r]
            '''print(la, vac,  r, deleted_atom, atoms_NN[deleted_atom], atoms_NNN[deleted_atom])
            print(valid_list)'''
            atom_deleted_flag[deleted_atom] = 1
            # pop this and all NN from valid_list
            valid_list.pop(r)

            # in-place list comprehension to delete element from list
            # https://stackoverflow.com/questions/1207406/how-to-remove-items-from-a-list-while-iterating
            valid_list[:] = [x for x in valid_list if not (x in atoms_NN[deleted_atom])]
            valid_list[:] = [x for x in valid_list if not (x in atoms_NNN[deleted_atom])]
            # These lines remove all the nearest neighbours of the NNN
            valid_list[:] = [x for x in valid_list if not (x in atoms_NN[atoms_NNN[deleted_atom][0]])]
            valid_list[:] = [x for x in valid_list if not (x in atoms_NN[atoms_NNN[deleted_atom][1]])]
            valid_list[:] = [x for x in valid_list if not (x in atoms_NN[atoms_NNN[deleted_atom][2]])]
            valid_list[:] = [x for x in valid_list if not (x in atoms_NN[atoms_NNN[deleted_atom][3]])]
            valid_list[:] = [x for x in valid_list if not (x in atoms_NN[atoms_NNN[deleted_atom][4]])]
            valid_list[:] = [x for x in valid_list if not (x in atoms_NN[atoms_NNN[deleted_atom][5]])]

            # reconstruct the defect

            # select two random neighbours
            fixed = randint(0, 2)
            vac_nn = atoms_NN[deleted_atom]
            vac_nn = np.delete(vac_nn, fixed)

            # get unit vector between the two atoms to be reconstructed
            dist = (atoms_array[vac_nn[0]] - atoms_array[vac_nn[1]])

            # move atoms through boundary if required
            # x
            if dist[0] > a_const * 2:
                atoms_array[vac_nn[0]][0] -= init_box_x
            if dist[0] < -a_const * 2:
                atoms_array[vac_nn[0]][0] += init_box_x
            # y
            if dist[1] > a_const * 2:
                atoms_array[vac_nn[0]][1] -= init_box_y
            if dist[1] < -a_const * 2:
                atoms_array[vac_nn[0]][1] += init_box_y

            # recalculate vector
            dist = (atoms_array[vac_nn[0]] - atoms_array[vac_nn[1]])

            # normalise vector
            if np.linalg.norm(dist) < a_const * 1.1:
                dist = dist / np.linalg.norm(dist)
            else:
                dist = -dist / np.linalg.norm(dist)

            # pinch atoms
            atoms_array[vac_nn[0]] = atoms_array[vac_nn[0]] - dist * a_const * 0.2
            atoms_array[vac_nn[1]] = atoms_array[vac_nn[1]] + dist * a_const * 0.2

            # wrap atoms that are now outside the boundary
            if atoms_array[vac_nn[0]][0] < 0:
                atoms_array[vac_nn[0]][0] += init_box_x
            if atoms_array[vac_nn[0]][0] > init_box_x:
                atoms_array[vac_nn[0]][0] -= init_box_x
            if atoms_array[vac_nn[0]][1] < 0:
                atoms_array[vac_nn[0]][1] += init_box_y
            if atoms_array[vac_nn[0]][1] > init_box_y:
                atoms_array[vac_nn[0]][1] -= init_box_y
            if atoms_array[vac_nn[1]][0] < 0:
                atoms_array[vac_nn[1]][0] += init_box_x
            if atoms_array[vac_nn[1]][0] > init_box_x:
                atoms_array[vac_nn[1]][0] -= init_box_x
            if atoms_array[vac_nn[1]][1] < 0:
                atoms_array[vac_nn[1]][1] += init_box_y
            if atoms_array[vac_nn[1]][1] > init_box_y:
                atoms_array[vac_nn[1]][1] -= init_box_y

        # project points onto cylinder surface, use new array
        atoms_array_new = np.zeros((tot_atoms, 3))
        for i in range(tot_atoms):
            atoms_array_new[i][1] = atoms_array[i][1]
            atoms_array_new[i][0] = nanotube_radius * math.sin(atoms_array[i][0] / nanotube_radius)
            atoms_array_new[i][2] = nanotube_radius * math.cos(atoms_array[i][0] / nanotube_radius)

        # translate
        for i in range(tot_atoms):
            atoms_array_new[i][0] = atoms_array_new[i][0] + box_y / 2.0
            atoms_array_new[i][2] = atoms_array_new[i][2] + box_z / 2.0

        # Output data:  ID type x y z
        # Note we switch x and y, since we wrap around y axis and want nanotube rotated so length is along x
        count = 0
        for cnt in range(tot_atoms):
            if atom_deleted_flag[cnt] == 0:
                file.write(str(count + 1) + " 1 " +
                           str(atoms_array_new[cnt][1]) + " " +
                           str(atoms_array_new[cnt][0]) + " " +
                           str(atoms_array_new[cnt][2]) + "\n")
                count += 1

        file.close()

        if verbose:
            print("file closed: " + str(file.name))
            print("COMPLETED lattice.dat output !!")


# If we are running this script interactively, call the function safely
if __name__ == '__main__':

    my_cells = [1, 1]
    my_num_vacs = 0

    # Read number of lattice cells from the command-line, or supply interactively
    if len(sys.argv) > 1:
        print(">  Using information passed on the command-line")
        # 2 params = cell size
        if len(sys.argv) == 3:
            my_cells[0] = int(sys.argv[1])
            my_cells[1] = int(sys.argv[2])
        elif len(sys.argv) == 4:
            my_cells[0] = int(sys.argv[1])
            my_cells[1] = int(sys.argv[2])
            my_num_vacs = int(sys.argv[3])
        else:
            print(">>> ERROR  <<<")
            print("  User must pass 2 or 3 command-line arguments")
            print("   2 params = box_x, box_y  (integers)")
            print("   3 params = box_x, box_y, Num_vacancies  (integers)")
            print("    examples")
            print("   lammps_gen_nanotube_armchair_airebo.py 1 2 ")
            print("   lammps_gen_nanotube_armchair_airebo.py 10 21")
            print("   lammps_gen_nanotube_armchair_airebo.py 10 21 5")
            sys.exit()
    else:
        # Otherwise, ask user, cell dimensions and num vacancies
        while True:
            try:
                cellsize = int(input('Enter number of cells in x dir (nanotube circumference): '))
                if cellsize > 0:
                    break
                else:
                    print("Oops!  Integer must be greater than 0.  Try again...")
            except ValueError:
                print("Oops!  That was not a valid integer.  Try again...")
        my_cells[0] = cellsize
        while True:
            try:
                cellsize = int(input('Enter number of cells in y dir (nanotube length): '))
                if cellsize > 0:
                    break
                else:
                    print("Oops!  Integer must be greater than 0.  Try again...")
            except ValueError:
                print("Oops!  That was not a valid integer.  Try again...")
        my_cells[1] = cellsize
        while True:
            try:
                my_num_vacs = int(input('Enter number of monovacancies: '))
                if my_num_vacs >= 0:
                    break
                else:
                    print("Oops!  Integer must not be negative.  Try again...")
            except ValueError:
                print("Oops!  That was not a valid integer.  Try again...")

    # call the nanotube generator function
    lammps_gen_nanotube_armchair_airebo_monovac(verbose=True,
                                                forced=True,
                                                cells=my_cells,
                                                num_vacancies=my_num_vacs)
